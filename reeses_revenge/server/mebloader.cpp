#include "common.h"

#if 0
/* C:\common_source\meps_elfconverter\meps_elfconverter\pub.key (7/7/2013 1:00:52 AM)
   StartOffset: 00000000, EndOffset: 000001C2, Length: 000001C3 */
unsigned char g_publicKey[451] = {
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50,
	0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D,
	0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x42, 0x49, 0x6A, 0x41, 0x4E, 0x42,
	0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
	0x51, 0x45, 0x46, 0x41, 0x41, 0x4F, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4D,
	0x49, 0x49, 0x42, 0x43, 0x67, 0x4B, 0x43, 0x41, 0x51, 0x45, 0x41, 0x75,
	0x31, 0x46, 0x51, 0x78, 0x67, 0x48, 0x30, 0x78, 0x77, 0x50, 0x6F, 0x2F,
	0x50, 0x6F, 0x55, 0x31, 0x75, 0x31, 0x6B, 0x0A, 0x51, 0x2F, 0x52, 0x35,
	0x36, 0x56, 0x76, 0x57, 0x4F, 0x76, 0x76, 0x48, 0x51, 0x70, 0x4C, 0x6C,
	0x31, 0x5A, 0x43, 0x31, 0x58, 0x61, 0x70, 0x58, 0x56, 0x78, 0x7A, 0x66,
	0x4B, 0x42, 0x4F, 0x67, 0x41, 0x57, 0x4E, 0x62, 0x46, 0x77, 0x62, 0x57,
	0x72, 0x6A, 0x63, 0x4D, 0x38, 0x38, 0x58, 0x37, 0x58, 0x4D, 0x4F, 0x6A,
	0x53, 0x4C, 0x35, 0x70, 0x6D, 0x55, 0x68, 0x36, 0x4A, 0x30, 0x6A, 0x62,
	0x0A, 0x67, 0x4D, 0x50, 0x35, 0x76, 0x4C, 0x5A, 0x53, 0x6F, 0x64, 0x34,
	0x42, 0x6D, 0x4A, 0x53, 0x49, 0x76, 0x58, 0x4C, 0x57, 0x5A, 0x4E, 0x57,
	0x41, 0x4B, 0x66, 0x33, 0x44, 0x4D, 0x4C, 0x4C, 0x56, 0x71, 0x59, 0x72,
	0x4B, 0x55, 0x52, 0x4E, 0x32, 0x4E, 0x65, 0x31, 0x70, 0x46, 0x75, 0x35,
	0x48, 0x2F, 0x56, 0x47, 0x5A, 0x6C, 0x61, 0x72, 0x53, 0x77, 0x38, 0x48,
	0x77, 0x4B, 0x5A, 0x59, 0x37, 0x0A, 0x47, 0x4E, 0x5A, 0x7A, 0x2F, 0x78,
	0x41, 0x6B, 0x6A, 0x56, 0x6A, 0x4F, 0x6B, 0x4B, 0x6D, 0x73, 0x49, 0x42,
	0x69, 0x56, 0x4E, 0x70, 0x73, 0x45, 0x75, 0x61, 0x55, 0x74, 0x34, 0x6A,
	0x76, 0x7A, 0x42, 0x4B, 0x71, 0x30, 0x76, 0x73, 0x4E, 0x66, 0x74, 0x4E,
	0x74, 0x36, 0x58, 0x57, 0x76, 0x69, 0x70, 0x7A, 0x44, 0x2B, 0x4A, 0x6A,
	0x59, 0x46, 0x77, 0x32, 0x66, 0x54, 0x57, 0x71, 0x4F, 0x66, 0x0A, 0x54,
	0x62, 0x46, 0x6D, 0x47, 0x61, 0x4F, 0x76, 0x63, 0x6B, 0x61, 0x56, 0x76,
	0x46, 0x30, 0x51, 0x4A, 0x72, 0x57, 0x47, 0x68, 0x7A, 0x6B, 0x77, 0x4A,
	0x63, 0x75, 0x6B, 0x2B, 0x7A, 0x59, 0x43, 0x74, 0x4B, 0x55, 0x59, 0x43,
	0x79, 0x57, 0x53, 0x45, 0x79, 0x56, 0x4D, 0x63, 0x4E, 0x6F, 0x58, 0x42,
	0x39, 0x4E, 0x51, 0x75, 0x4F, 0x42, 0x2B, 0x4D, 0x54, 0x62, 0x36, 0x74,
	0x61, 0x6A, 0x4C, 0x0A, 0x77, 0x2B, 0x56, 0x70, 0x4D, 0x39, 0x74, 0x2F,
	0x72, 0x4B, 0x4D, 0x64, 0x36, 0x67, 0x35, 0x71, 0x6E, 0x7A, 0x44, 0x51,
	0x6A, 0x6B, 0x51, 0x42, 0x46, 0x6B, 0x5A, 0x6F, 0x35, 0x50, 0x77, 0x76,
	0x34, 0x41, 0x49, 0x46, 0x6B, 0x67, 0x41, 0x79, 0x77, 0x75, 0x55, 0x51,
	0x31, 0x38, 0x51, 0x30, 0x6E, 0x57, 0x78, 0x64, 0x65, 0x4E, 0x66, 0x56,
	0x53, 0x73, 0x54, 0x2B, 0x72, 0x59, 0x6B, 0x38, 0x0A, 0x56, 0x51, 0x49,
	0x44, 0x41, 0x51, 0x41, 0x42, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45,
	0x4E, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45,
	0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x00
};
#endif
/* C:\Users\jdw\OneDrive\Documents\DEFCON\QUALS17\REESES_REVENGE\pub.key (4/25/2017 11:03:36 PM)
   StartOffset: 00000000, EndOffset: 000001C2, Length: 000001C3 */

unsigned char g_publicKey[451] = {
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x50,
	0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D,
	0x2D, 0x2D, 0x0A, 0x4D, 0x49, 0x49, 0x42, 0x49, 0x6A, 0x41, 0x4E, 0x42,
	0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
	0x51, 0x45, 0x46, 0x41, 0x41, 0x4F, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4D,
	0x49, 0x49, 0x42, 0x43, 0x67, 0x4B, 0x43, 0x41, 0x51, 0x45, 0x41, 0x75,
	0x61, 0x57, 0x53, 0x36, 0x58, 0x58, 0x78, 0x54, 0x32, 0x6E, 0x47, 0x4D,
	0x39, 0x2F, 0x78, 0x64, 0x35, 0x53, 0x35, 0x0A, 0x75, 0x42, 0x57, 0x57,
	0x6D, 0x65, 0x53, 0x45, 0x32, 0x42, 0x7A, 0x59, 0x73, 0x6A, 0x66, 0x50,
	0x38, 0x78, 0x49, 0x6F, 0x2F, 0x75, 0x49, 0x4B, 0x30, 0x79, 0x57, 0x62,
	0x4B, 0x67, 0x36, 0x72, 0x4A, 0x72, 0x6C, 0x38, 0x59, 0x42, 0x6C, 0x6C,
	0x45, 0x2B, 0x47, 0x37, 0x70, 0x61, 0x6A, 0x45, 0x67, 0x6D, 0x2B, 0x4E,
	0x56, 0x69, 0x72, 0x4B, 0x4D, 0x73, 0x71, 0x6B, 0x2B, 0x64, 0x74, 0x53,
	0x0A, 0x43, 0x30, 0x77, 0x33, 0x76, 0x44, 0x6D, 0x47, 0x36, 0x61, 0x70,
	0x6C, 0x67, 0x7A, 0x5A, 0x69, 0x43, 0x2B, 0x44, 0x73, 0x4E, 0x32, 0x48,
	0x58, 0x78, 0x42, 0x6C, 0x39, 0x33, 0x52, 0x2B, 0x43, 0x79, 0x64, 0x2B,
	0x72, 0x33, 0x54, 0x67, 0x73, 0x47, 0x32, 0x73, 0x41, 0x72, 0x6F, 0x63,
	0x53, 0x4B, 0x78, 0x71, 0x30, 0x67, 0x51, 0x64, 0x5A, 0x6E, 0x48, 0x36,
	0x70, 0x47, 0x61, 0x6F, 0x6A, 0x0A, 0x6C, 0x63, 0x4E, 0x54, 0x68, 0x58,
	0x6B, 0x53, 0x6D, 0x59, 0x31, 0x34, 0x2B, 0x6E, 0x7A, 0x50, 0x30, 0x31,
	0x51, 0x41, 0x35, 0x63, 0x38, 0x58, 0x4E, 0x4E, 0x6E, 0x51, 0x74, 0x6B,
	0x57, 0x4B, 0x6B, 0x61, 0x4D, 0x73, 0x36, 0x69, 0x64, 0x76, 0x47, 0x67,
	0x63, 0x2B, 0x4F, 0x2B, 0x33, 0x79, 0x50, 0x49, 0x63, 0x42, 0x59, 0x33,
	0x68, 0x79, 0x51, 0x41, 0x6D, 0x61, 0x4F, 0x47, 0x66, 0x67, 0x0A, 0x6C,
	0x47, 0x71, 0x6D, 0x39, 0x50, 0x38, 0x52, 0x42, 0x4D, 0x64, 0x30, 0x65,
	0x71, 0x57, 0x58, 0x47, 0x49, 0x6A, 0x54, 0x4C, 0x67, 0x56, 0x4D, 0x67,
	0x39, 0x52, 0x57, 0x51, 0x57, 0x46, 0x35, 0x57, 0x44, 0x58, 0x70, 0x64,
	0x62, 0x77, 0x62, 0x36, 0x59, 0x75, 0x62, 0x4B, 0x6D, 0x4F, 0x78, 0x4B,
	0x69, 0x48, 0x57, 0x50, 0x67, 0x6B, 0x31, 0x4C, 0x2B, 0x2B, 0x49, 0x41,
	0x33, 0x57, 0x34, 0x0A, 0x31, 0x51, 0x61, 0x37, 0x62, 0x41, 0x67, 0x35,
	0x76, 0x73, 0x70, 0x4E, 0x33, 0x62, 0x67, 0x55, 0x39, 0x4B, 0x58, 0x6B,
	0x4F, 0x72, 0x4A, 0x4C, 0x35, 0x61, 0x35, 0x6B, 0x6A, 0x58, 0x2F, 0x7A,
	0x31, 0x75, 0x33, 0x47, 0x53, 0x32, 0x6B, 0x37, 0x57, 0x5A, 0x4E, 0x55,
	0x48, 0x33, 0x58, 0x43, 0x75, 0x49, 0x58, 0x68, 0x35, 0x33, 0x62, 0x6A,
	0x54, 0x7A, 0x38, 0x2B, 0x64, 0x6B, 0x48, 0x44, 0x0A, 0x6E, 0x77, 0x49,
	0x44, 0x41, 0x51, 0x41, 0x42, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45,
	0x4E, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4C, 0x49, 0x43, 0x20, 0x4B, 0x45,
	0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A
};


bool CMebLoader::LoadFile( uint8_t *pData, uint32_t dataSize, std::string &sErrorText )
{
	if ( dataSize < sizeof(Meb32_Hdr) )
	{
		sErrorText = "Invalid file format. File too small.";
		return false;
	}

	Meb32_Hdr oHeader;

	memcpy( &oHeader, pData, sizeof(Meb32_Hdr) );

	if ( oHeader.lsec_num > 100 || oHeader.rsec_num > 33 )
	{
		sErrorText = "Invalid file format. File contains too many sections.";
		return false;
	}

	// Calculate size of lsec, rsec, and sig
	uint32_t totalHeaderSize = (sizeof(Meb32_Hdr) + (sizeof(Meb32_LSec)*oHeader.lsec_num) + (sizeof(Meb32_RSec)*oHeader.rsec_num) + sizeof(Meb32_Sig));

	if ( dataSize < totalHeaderSize )
	{
		sErrorText = "Invalid file format. File too small.";
		return false;
	}

	// Check signature!
	if ( dataSize != (oHeader.sig_offset + sizeof(Meb32_Sig)) )
	{
		sErrorText = "Invalid file format. File incorrect size.";
		return false;
	}

	Meb32_Sig oSig;
	memcpy( &oSig, (pData+oHeader.sig_offset), sizeof(Meb32_Sig) );

	// Check signature
	Crypto oCrypto;

	oCrypto.setPublicKey( g_publicKey, sizeof(g_publicKey) );

	// Now verify!
	if ( oCrypto.rsaVerify( pData, oHeader.sig_offset, oSig.signed_hash, sizeof(oSig.signed_hash) ) != SUCCESS )
	{
		sErrorText = "Invalid file format. Signature failed.";
		return false;
	}

	// Setup MMU (192KB of RAM for text/data)
	m_oMMU.Setup( 0x400000, 0x430000 );
	
	// Load LSecs
	for ( uint32_t i = 0; i < oHeader.lsec_num; i++ )
	{
		Meb32_LSec oSec;

		uint32_t posOffset = oHeader.lsec_offset+(sizeof(Meb32_LSec)*i);

		if ( posOffset+sizeof(Meb32_LSec) > dataSize )
		{
			sErrorText = "Invalid file format. Offset out of range.";
			return false;
		}

		memcpy( &oSec, (pData+oHeader.lsec_offset+(sizeof(Meb32_LSec)*i)), sizeof(Meb32_LSec) );

		if ( oSec.fileOffset+oSec.fileSize > dataSize )
		{
			sErrorText = "Invalid file format. LSec data offset out of range.";
			return false;
		}

		// Load section into MMU memory
		m_oMMU.WriteMemory( oSec.startAddr, (pData+oSec.fileOffset), oSec.fileSize );
	}

	m_oCPU.setup( &m_oMMU, &m_oSysCallHandler, 0x0, false, 0x0 );

	for ( uint32_t i = 0; i < oHeader.rsec_num; i++ )
	{
		Meb32_RSec oSec;

		uint32_t posOffset = oHeader.rsec_offset + (sizeof(Meb32_RSec)*i);

		if ( posOffset+sizeof(Meb32_RSec) > dataSize )
		{
			sErrorText = "Invalid file format. Offset out of range.";
			return false;
		}

		memcpy( &oSec, (pData+posOffset), sizeof(Meb32_RSec) );

		m_oCPU.setRegisterAndPC( oSec.regNum, oSec.regValue );
	}

	return (true);
}

bool CMebLoader::Run( void )
{
	printf( "<<RUNNING>>\n");
	
	for (;;)
	{
		m_oCPU.step();
	}
}
